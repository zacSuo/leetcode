---
title: 3种解法： 判断矩形重叠
categories:
  - 技术资料
  - 算法
tags:
  - 矩形重叠
  - 矩形
  - 逆向思考
  - 中心距离
date: 2020-03-17 19:34:29
updated: 2020-03-17 19:34:29
description: 使用（逆向思路、计算交集、计算中心距离）3种解法，来判断两个矩形是否有重叠...
---

## 题目
矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。

如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。

给出两个矩形，判断它们是否重叠并返回结果。

示例 1：

输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true
示例 2：

输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
输出：false
说明：

两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。
矩形中的所有坐标都处于 -10^9 和 10^9 之间。
***
## 解法一（逆向思考）
思路：两个矩形的重叠相当于XY两个方向线段都有相交，为了理解简化仅考虑X方向，两个AB线段的分布有8种情况，如图所示，其中1\2\7\8情况的条件最容易判断，其特点是一个的最大值不大于另一个的最小值，因此判断不相交的情况即可，对于另一个方向也同样原理。
1. 进行X方向，不相交的判断
2. 进行Y反向，不相交的判断
3. 整体进行取反，则得到相交的判断

<center>    <img src="/img/tech/20200318094727.png" title="示意图"/>    </center>

```python
#author : suoxd123@126.com
class Solution:
    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:
        return not (rec1[0] >= rec2[2] or rec1[1] >= rec2[3] or rec2[0] >= rec1[2] or rec2[1] >= rec1[3])
```
## 解法二（计算交集）
思路：上面解法一通过判断是否不相交，反过来得到是否相交，当前解法通过分析交集本身，来寻找总结相交的规律。分析思路同解法一，先只分析X方向的情况。
当X方向AB两条线段重叠时，交集有个特点就是属于两条线段的范围，即交集左边坐标等于AB左边最大值，交集右边坐标等于AB右边最小值，如果交集左边坐标小于右边坐标，即表示相交。
1. 获取X方向投影的交集
2. 获取Y方向投影的交集
3. 同时满足两个方向有交集的情况时，两个矩形有重叠
```python
class Solution:
#author : suoxd123@126.com
    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:
        return max(rec1[0],rec2[0]) < min(rec1[2],rec2[2]) and max(rec1[1],rec2[1]) < min(rec1[3],rec2[3]) 
```
## 解法三（计算中心距离）
思路：同样，先将二维的矩形先投影到一维做分析，对于X方向的两条线段，对于AB两条线段1\2\7\8的情况满足AB线段中心的间距大于等于两条线段长度的一半，即1\8两种情况是线段中心坐标间距大于线段长度的一半，2\7两种是等于（线段相接），因此可以直接通过中心距离进行判断。

同样的原理，也可以直接求解两个矩形中心的距离，即如果两个矩形对角线一半长度的和 跟 两个矩形中心间距做对比，如果长度大于距离则两个矩形重叠，相反则不重叠。

1. 先计算X方向线段中心距离，再计算X方向两条线段长度的一半
2. 同样的原理再计算Y方向，然后进行判断，由于两边都要除以2，因此可以都不除
3. 同时满足两个方向进行判断，可以直接判断，也可以类似解法一一样，先求不满足，然后取反

```python
class Solution:
#author : suoxd123@126.com
    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:
        return (rec1[2] - rec1[0] + rec2[2] - rec2[0]) > abs(rec1[0] + rec1[2] - rec2[0] - rec2[2]) \
            and (rec1[3] - rec1[1] + rec2[3] - rec2[1]) > abs(rec1[1] + rec1[3] - rec2[1] - rec2[3])
        
```
